#!/bin/bash
shopt -s expand_aliases

## Prototype, git workflow to crips git repositories

W=./ # git worktree
declare -a FETCHED=('')
FETCH_DEPENDENCIES=${CROSS_FETCH_DEPENDENCIES:-false}

# git setup
setup() {
  # require git >=2.20
  git config extensions.worktreeConfig true
  git worktree prune

  export MAGENTA='\033[0;95m'
  export YELLOW='\033[1;33m'
  export NC='\033[0m' # No Color'
}

# use, is virtual function for DSL like syntax to configure sources
# it add upstream as remote to tracking branch
use() {
  [[ -n "$1" ]] || say "USE called without an argument: remote name"
  [[ -n "$2" ]] || say "USE called without an argument: repo url"
  name=$1
  [[ $(git remote show | grep $name) ]] ||
    git remote add $@
}

# patch, track 'origin/path' as branch and checkout it to your git worktree
patch() {
  # origin:path/to/folder [path/in/my/repo] [-b branch]
  # core:habitat/corends coredns -b master

  from=$1
  orig=$(cut -d: -f1 <<<"$from") # origin
  opth=$(cut -d: -f2 <<<"$from") # origin path
  path=${2:-$opth}
  branch=${4:-master}

  # skip already processed dependencies
  [[ "${FETCHED[*]}" =~ $path ]] && return 0

  if [[ -e $W/$path ]]; then
    # update if present
    pushd $W/$path
    git --git-dir=$(sed 's/gitdir: //g' .git) stash
    if repo_is_clean; then
      say "$orig/$path"
      git fetch --prune --depth=1 $orig $branch
      git rebase
    else
      say "$orig/$path skipped (uncommitted changes)"
    fi
    popd
  else
    # track and fetch new
    say "Tracking $orig:$opth (branch:$branch) at /$path"
    git fetch --prune --depth=1 $orig $branch:$orig/$path
    git worktree add --no-checkout -B "$orig/$path" $W/$path --track $orig/$branch
    pushd $W/$path
    sparse_checkout=$(git rev-parse --git-path info/sparse-checkout)
    # first time configure $name into info/sparse-checkout
    if ! [[ $(cat $sparse_checkout 2>/dev/null) =~ ^/$opth/ ]]; then
      git config --worktree --bool core.sparseCheckout true
      git config --worktree --path core.worktree $PWD/..
      [[ -e $sparse_checkout ]] ||
        mkdir -p $(dirname $sparse_checkout)
      echo "/$opth/" | tee -a $sparse_checkout >/dev/null
    fi
    git checkout
    popd
    git --git-dir=.git --work-tree=. add $path/*
  fi

  FETCHED+=($name)

  # dependencies
  if ${FETCH_DEPENDENCIES}; then
    for p in $(cross_dependencies $path); do patch $p; done
  fi
}

# STAFF AROUND
repo_is_clean() {
  git diff-index --quiet HEAD --
}
pushd() {
  export OLDPW=$PWD
  cd "$@" >/dev/null
}
popd() {
  cd - >/dev/null
}
say() {
  (echo >&2 -e "\n${MAGENTA}$1${NC}")
  [[ -z ${2:-''} ]] || exit $2
}
ask() {
  local prompt default reply
  while true; do
    if [[ "${2:-}" =~ ^Y ]]; then
      prompt="Y/n"
      default=Y
    elif [[ "${2:-}" =~ ^N ]]; then
      prompt="y/N"
      default=N
    fi
    say "\n$1 [$prompt]"
    read reply
    reply=${reply:-$default}
    case "$reply" in
    Y* | y*) return 0 ;;
    N* | n*) return 1 ;;
    *) return 1 ;;
    esac
  done
}

# allow to be sourced or used individually
if [[ "$BASH_SOURCE" == "$0" ]]; then
  set -eu -o pipefail
  setup
  if [[ $# -gt 0 ]]; then
    # exec individual action
    fn=$1
    shift
    $fn $@
  else
    repo_is_clean || ask "There are uncommitted changes in the repository. Continue?" Y
    [ -e *.cross ] && source *.cross
    [ -e .*.cross ] && source .*.cross
  fi
fi
